#pragma config(Sensor, S2,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     colorLeft,      sensorEV3_Color)
#pragma config(Sensor, S4,     colorRight,     sensorEV3_Color)
#pragma config(Motor,  motorA,          leftM,         tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightM,        tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This is used for the initial calibration. It was initially thought that this would be used in more instances
//This was not the case, but there's no sense in removing it now.
#define COLOR_SENSOR_AVERAGE_BUFFER_LEN 10
#define SONAR_SENSOR_AVERAGE_BUFFER_LEN 10

//The weight of new values when following a line. A higher weight allows for more precise line following.
#define MOVING_AVG_WEIGHT 75.0

//Needed a middling weight for reacquiring lines. This turned out to be a good weight.
#define REAQ_MVG_WEIGHT 45.0

//the distance should stop when it reach
#define STOP_DIST 20

//Some default values for upper and lower bound colors, but this is dynamically set on startup.
//The lower bound which determines what reading we consider to be black
int COLOR_LOWER_BOUND = 5;

//The upper bound color above which we consider our reading to be white again.
//Actual working values for white are reading around 20-30
int COLOR_UPPER_BOUND = 60;

//These globals track the average for color and distance.
//These values are modified when accessing the get*Avg() functions
float avgColorLeft = 0,
    avgColorRight = 0;
int sonarAvg = 255;




//the ratio will change over time
int myRatio = 5;
//Array of turning ratios
int myRatioArray[11] = {
	-35,
	-30,
	-20,
	-15,
	-10,
	0,
	10,
	15,
	20,
	30,
	35
};

void moveForward();
task moveBot();
void getNewRatio();
float getMovingAvg(float lastAvg, float alpha, int newestReading);
void getSonarAvg(float weight);
void getColorAvg(float weight);
void mv(int left, int right);
void randomDir();
task objectDetect();
void calBlack();
void calWhite();


task main()
{
	 //Calibrate black after two seconds on startup
   setLEDColor(ledOrangeFlash);
   delay(2000);
   calBlack();

   //After that, calibrate white
   setLEDColor(ledGreenFlash);
   delay(2000);
   calWhite();
    
	startTask(moveBot);
	wait1Msec(100);
	startTask(objectDetect);
	while (true){};
}





//Get a moving average with the last average taken (lastAvg),
//the alpha weight desired and the newest reading.
float getMovingAvg(float lastAvg, float alpha, int newestReading) {
    return lastAvg + (alpha * (newestReading - lastAvg));
}


//Sets the moving average for sonar
//In the body is an unused technique to discard outliers by weighting them inversely to
//how far away from the average they are.
void getSonarAvg(float weight) {
    //so we want yet another weight which attempts to reject deviant values
    //we can derive this weight from the newest reading's deviation from the current average
    //This weight should have a minimum amount, should always be positive
    // diff = min ( 1, sonarAvg - sonarVar) never let this be zero to avoid div by zero among other things
    // weight = max ( 1, 10 / diff ); let the final weight here never be greater than one
    // This last statement basically accepts the full weight value of deviations by
    int sonarVar;
    sonarVar = getUSDistance(sonar);

    //float diff = min ( 1, sonarAvg - sonarVar ); //never let this be zero to avoid div by zero among other things
    //float weight = max ( 1, 10 / diff ); //let the final weight here never be greater than one

    sonarAvg = getMovingAvg(sonar
    Avg, weight / 100.0, sonarVar);
}

//Set the color average with the given weight
//Using only the green and blue channel values because red returns with less dynamic range and
//drags the whole average down.
void getColorAvg(float weight) {
    //long r, g, b;
    //getColorRGB(colorLeft, r, g, b);
    //float cLeft = (g + b) / 2.0;

    //getColorRGB(colorRight, r, g, b);
    //float cRight = (g + b) / 2.0;

		float leftReflected = getColorReflected(colorLeft) * 1.0;
		
		float rightReflected = getColorReflected(colorRight) * 1.0;

    avgColorLeft = getMovingAvg(avgColorLeft, weight / 100.0, leftReflected);
    avgColorRight = getMovingAvg(avgColorRight, weight / 100.0, rightReflected);
    //writeDebugStreamLine("left: %f, right: %f", avgColorLeft, avgColorRight); debugger
}

//Priority * - OBJECT DETECTION
//Kill line detection to chase object and kill wander
//3 feet is approximately 90 from the getDistance function
task objectDetect() {
    //stopTask(lineFollow);
    bool detected;
    while (true) {

        if (detected) {//When the object is detected, set a higher weight to the mvg avg
            getSonarAvg(50.0);
        } else {
            delay(100);
            getSonarAvg(15.0);
        }

        //If we detect an object, speed off towards it
        if (sonarAvg < 90 && sonarAvg > STOP_DIST) {
            detected = true;
            stopTask(moveBot);
            //stopTask(lineFollow);
            setLEDColor(ledOff);

            float actualSpeed = (sonarAvg / 90.0) * 128;
            writeDebugStreamLine("speed: %f", actualSpeed);
            mv(actualSpeed, actualSpeed);
            delay(10);
        } else if (sonarAvg <= STOP_DIST && detected) {//Otherwise if we're lower than the stop dist after detection
            mv(0, 0);

            wait1Msec(2000);

            mv(-55, -55);

            detected = false;
            sonarAvg = 255;
            wait1Msec(200);
            randomDir();
            startTask(moveBot);
            delay(100);
            //startTask(lineFollow);
            delay(100);
        } else if (sonarAvg > 90 && detected) {//If the object disappears after being detcted
            detected = false;
            sonarAvg = 255;
            startTask(moveBot);
            delay(100);
            //startTask(lineFollow);
            delay(100);
        }
    } 

}

//Helper function for a really terse way to set both motor speeds
void mv(int left, int right) {
    setMotorSpeed(leftM, left);
    setMotorSpeed(rightM, right);
}

//Let the robot turn in a random direction
void randomDir() {
    long turnProb = 0;
    turnProb = rand() % 100;
    if (turnProb < 50) {
        turnLeft();
    } else {
        turnRight();
    }
}


//CALIBRATIONS
//Do the calibration for the black values
void calBlack() {
    for (int i = 0; i < 10; i++) {
        getColorAvg(MOVING_AVG_WEIGHT);
        delay(100);
    }

    COLOR_LOWER_BOUND = ((avgColorLeft + avgColorRight) / 2);
}

//Do calibration for white values
void calWhite() {
    for (int i = 0; i < 10; i++) {
        getColorAvg(MOVING_AVG_WEIGHT);
        delay(100);
    }

    COLOR_UPPER_BOUND = ((avgColorLeft + avgColorRight) / 2);
}












/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//start with biased random walk
task moveBot() {
	// Choose new direction
	moveForward();
}

/*
move forward based on the random ratio generated
*/
void moveForward() {
	// Infinitely choose new ratio of turn and go for 100ms
	while (true) {
		getNewRatio();
		wait1Msec(800);
	}
}

/*
Bayesian Network implementation of biased random walk.
Chooses a new ratio of turn with probability directly
linked to current ratio of turn.
*/
void getNewRatio() {
	int i=0, j, k;
	//Creates array 0-9 that will be filled with
	// possible ratios. Represents percent chance.
	int arr[10];
	// Fills part of array with probability of going
	// one index less on myRatioArray
	for (j = 0; j < myRatio; j++) {
		arr[i++] = myRatio - 1;
	}
	// Fills part of array with probability of going
	// one index more on myRatioArray
	for (k = myRatio; k < 10; k++) {
		arr[i++] = myRatio + 1;
	}
	int randomInt = random(9);
	int selection = arr[randomInt];
	if (selection == 0 || selection == 10) {
		myRatio = 5;
	} else
		myRatio = selection;
	setMotorSync(leftM,rightM,myRatioArray[selection],35);
}
